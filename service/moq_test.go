// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"database/sql"
	"github.com/yuyacode/AppLiftMessageApi/entity"
	"github.com/yuyacode/AppLiftMessageApi/store"
	"sync"
)

// Ensure, that CredentialGetterMock does implement CredentialGetter.
// If this is not the case, regenerate this file with moq.
var _ CredentialGetter = &CredentialGetterMock{}

// CredentialGetterMock is a mock implementation of CredentialGetter.
//
//	func TestSomethingThatUsesCredentialGetter(t *testing.T) {
//
//		// make and configure a mocked CredentialGetter
//		mockedCredentialGetter := &CredentialGetterMock{
//			GetAPIKeyFunc: func(ctx context.Context, db store.Queryer) (string, error) {
//				panic("mock out the GetAPIKey method")
//			},
//			GetAccessTokenFunc: func(ctx context.Context, db store.Queryer, userID int64) (string, *sql.NullTime, error) {
//				panic("mock out the GetAccessToken method")
//			},
//			GetClientIDFunc: func(ctx context.Context, db store.Queryer, userID int64) (string, error) {
//				panic("mock out the GetClientID method")
//			},
//			GetClientSecretFunc: func(ctx context.Context, db store.Queryer, userID int64) (string, error) {
//				panic("mock out the GetClientSecret method")
//			},
//			GetRefreshTokenFunc: func(ctx context.Context, db store.Queryer, userID int64) (string, error) {
//				panic("mock out the GetRefreshToken method")
//			},
//			SearchByAccessTokenFunc: func(ctx context.Context, db store.Queryer, accessToken string) (bool, error) {
//				panic("mock out the SearchByAccessToken method")
//			},
//			SearchByClientIDFunc: func(ctx context.Context, db store.Queryer, clientID string) (bool, error) {
//				panic("mock out the SearchByClientID method")
//			},
//			SearchByClientSecretFunc: func(ctx context.Context, db store.Queryer, clientSecret string) (bool, error) {
//				panic("mock out the SearchByClientSecret method")
//			},
//			SearchByRefreshTokenFunc: func(ctx context.Context, db store.Queryer, refreshToken string) (bool, error) {
//				panic("mock out the SearchByRefreshToken method")
//			},
//		}
//
//		// use mockedCredentialGetter in code that requires CredentialGetter
//		// and then make assertions.
//
//	}
type CredentialGetterMock struct {
	// GetAPIKeyFunc mocks the GetAPIKey method.
	GetAPIKeyFunc func(ctx context.Context, db store.Queryer) (string, error)

	// GetAccessTokenFunc mocks the GetAccessToken method.
	GetAccessTokenFunc func(ctx context.Context, db store.Queryer, userID int64) (string, *sql.NullTime, error)

	// GetClientIDFunc mocks the GetClientID method.
	GetClientIDFunc func(ctx context.Context, db store.Queryer, userID int64) (string, error)

	// GetClientSecretFunc mocks the GetClientSecret method.
	GetClientSecretFunc func(ctx context.Context, db store.Queryer, userID int64) (string, error)

	// GetRefreshTokenFunc mocks the GetRefreshToken method.
	GetRefreshTokenFunc func(ctx context.Context, db store.Queryer, userID int64) (string, error)

	// SearchByAccessTokenFunc mocks the SearchByAccessToken method.
	SearchByAccessTokenFunc func(ctx context.Context, db store.Queryer, accessToken string) (bool, error)

	// SearchByClientIDFunc mocks the SearchByClientID method.
	SearchByClientIDFunc func(ctx context.Context, db store.Queryer, clientID string) (bool, error)

	// SearchByClientSecretFunc mocks the SearchByClientSecret method.
	SearchByClientSecretFunc func(ctx context.Context, db store.Queryer, clientSecret string) (bool, error)

	// SearchByRefreshTokenFunc mocks the SearchByRefreshToken method.
	SearchByRefreshTokenFunc func(ctx context.Context, db store.Queryer, refreshToken string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetAPIKey holds details about calls to the GetAPIKey method.
		GetAPIKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
		}
		// GetAccessToken holds details about calls to the GetAccessToken method.
		GetAccessToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserID is the userID argument value.
			UserID int64
		}
		// GetClientID holds details about calls to the GetClientID method.
		GetClientID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserID is the userID argument value.
			UserID int64
		}
		// GetClientSecret holds details about calls to the GetClientSecret method.
		GetClientSecret []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserID is the userID argument value.
			UserID int64
		}
		// GetRefreshToken holds details about calls to the GetRefreshToken method.
		GetRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserID is the userID argument value.
			UserID int64
		}
		// SearchByAccessToken holds details about calls to the SearchByAccessToken method.
		SearchByAccessToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// AccessToken is the accessToken argument value.
			AccessToken string
		}
		// SearchByClientID holds details about calls to the SearchByClientID method.
		SearchByClientID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// ClientID is the clientID argument value.
			ClientID string
		}
		// SearchByClientSecret holds details about calls to the SearchByClientSecret method.
		SearchByClientSecret []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// ClientSecret is the clientSecret argument value.
			ClientSecret string
		}
		// SearchByRefreshToken holds details about calls to the SearchByRefreshToken method.
		SearchByRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// RefreshToken is the refreshToken argument value.
			RefreshToken string
		}
	}
	lockGetAPIKey            sync.RWMutex
	lockGetAccessToken       sync.RWMutex
	lockGetClientID          sync.RWMutex
	lockGetClientSecret      sync.RWMutex
	lockGetRefreshToken      sync.RWMutex
	lockSearchByAccessToken  sync.RWMutex
	lockSearchByClientID     sync.RWMutex
	lockSearchByClientSecret sync.RWMutex
	lockSearchByRefreshToken sync.RWMutex
}

// GetAPIKey calls GetAPIKeyFunc.
func (mock *CredentialGetterMock) GetAPIKey(ctx context.Context, db store.Queryer) (string, error) {
	if mock.GetAPIKeyFunc == nil {
		panic("CredentialGetterMock.GetAPIKeyFunc: method is nil but CredentialGetter.GetAPIKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Queryer
	}{
		Ctx: ctx,
		Db:  db,
	}
	mock.lockGetAPIKey.Lock()
	mock.calls.GetAPIKey = append(mock.calls.GetAPIKey, callInfo)
	mock.lockGetAPIKey.Unlock()
	return mock.GetAPIKeyFunc(ctx, db)
}

// GetAPIKeyCalls gets all the calls that were made to GetAPIKey.
// Check the length with:
//
//	len(mockedCredentialGetter.GetAPIKeyCalls())
func (mock *CredentialGetterMock) GetAPIKeyCalls() []struct {
	Ctx context.Context
	Db  store.Queryer
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Queryer
	}
	mock.lockGetAPIKey.RLock()
	calls = mock.calls.GetAPIKey
	mock.lockGetAPIKey.RUnlock()
	return calls
}

// GetAccessToken calls GetAccessTokenFunc.
func (mock *CredentialGetterMock) GetAccessToken(ctx context.Context, db store.Queryer, userID int64) (string, *sql.NullTime, error) {
	if mock.GetAccessTokenFunc == nil {
		panic("CredentialGetterMock.GetAccessTokenFunc: method is nil but CredentialGetter.GetAccessToken was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetAccessToken.Lock()
	mock.calls.GetAccessToken = append(mock.calls.GetAccessToken, callInfo)
	mock.lockGetAccessToken.Unlock()
	return mock.GetAccessTokenFunc(ctx, db, userID)
}

// GetAccessTokenCalls gets all the calls that were made to GetAccessToken.
// Check the length with:
//
//	len(mockedCredentialGetter.GetAccessTokenCalls())
func (mock *CredentialGetterMock) GetAccessTokenCalls() []struct {
	Ctx    context.Context
	Db     store.Queryer
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}
	mock.lockGetAccessToken.RLock()
	calls = mock.calls.GetAccessToken
	mock.lockGetAccessToken.RUnlock()
	return calls
}

// GetClientID calls GetClientIDFunc.
func (mock *CredentialGetterMock) GetClientID(ctx context.Context, db store.Queryer, userID int64) (string, error) {
	if mock.GetClientIDFunc == nil {
		panic("CredentialGetterMock.GetClientIDFunc: method is nil but CredentialGetter.GetClientID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetClientID.Lock()
	mock.calls.GetClientID = append(mock.calls.GetClientID, callInfo)
	mock.lockGetClientID.Unlock()
	return mock.GetClientIDFunc(ctx, db, userID)
}

// GetClientIDCalls gets all the calls that were made to GetClientID.
// Check the length with:
//
//	len(mockedCredentialGetter.GetClientIDCalls())
func (mock *CredentialGetterMock) GetClientIDCalls() []struct {
	Ctx    context.Context
	Db     store.Queryer
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}
	mock.lockGetClientID.RLock()
	calls = mock.calls.GetClientID
	mock.lockGetClientID.RUnlock()
	return calls
}

// GetClientSecret calls GetClientSecretFunc.
func (mock *CredentialGetterMock) GetClientSecret(ctx context.Context, db store.Queryer, userID int64) (string, error) {
	if mock.GetClientSecretFunc == nil {
		panic("CredentialGetterMock.GetClientSecretFunc: method is nil but CredentialGetter.GetClientSecret was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetClientSecret.Lock()
	mock.calls.GetClientSecret = append(mock.calls.GetClientSecret, callInfo)
	mock.lockGetClientSecret.Unlock()
	return mock.GetClientSecretFunc(ctx, db, userID)
}

// GetClientSecretCalls gets all the calls that were made to GetClientSecret.
// Check the length with:
//
//	len(mockedCredentialGetter.GetClientSecretCalls())
func (mock *CredentialGetterMock) GetClientSecretCalls() []struct {
	Ctx    context.Context
	Db     store.Queryer
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}
	mock.lockGetClientSecret.RLock()
	calls = mock.calls.GetClientSecret
	mock.lockGetClientSecret.RUnlock()
	return calls
}

// GetRefreshToken calls GetRefreshTokenFunc.
func (mock *CredentialGetterMock) GetRefreshToken(ctx context.Context, db store.Queryer, userID int64) (string, error) {
	if mock.GetRefreshTokenFunc == nil {
		panic("CredentialGetterMock.GetRefreshTokenFunc: method is nil but CredentialGetter.GetRefreshToken was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetRefreshToken.Lock()
	mock.calls.GetRefreshToken = append(mock.calls.GetRefreshToken, callInfo)
	mock.lockGetRefreshToken.Unlock()
	return mock.GetRefreshTokenFunc(ctx, db, userID)
}

// GetRefreshTokenCalls gets all the calls that were made to GetRefreshToken.
// Check the length with:
//
//	len(mockedCredentialGetter.GetRefreshTokenCalls())
func (mock *CredentialGetterMock) GetRefreshTokenCalls() []struct {
	Ctx    context.Context
	Db     store.Queryer
	UserID int64
} {
	var calls []struct {
		Ctx    context.Context
		Db     store.Queryer
		UserID int64
	}
	mock.lockGetRefreshToken.RLock()
	calls = mock.calls.GetRefreshToken
	mock.lockGetRefreshToken.RUnlock()
	return calls
}

// SearchByAccessToken calls SearchByAccessTokenFunc.
func (mock *CredentialGetterMock) SearchByAccessToken(ctx context.Context, db store.Queryer, accessToken string) (bool, error) {
	if mock.SearchByAccessTokenFunc == nil {
		panic("CredentialGetterMock.SearchByAccessTokenFunc: method is nil but CredentialGetter.SearchByAccessToken was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Db          store.Queryer
		AccessToken string
	}{
		Ctx:         ctx,
		Db:          db,
		AccessToken: accessToken,
	}
	mock.lockSearchByAccessToken.Lock()
	mock.calls.SearchByAccessToken = append(mock.calls.SearchByAccessToken, callInfo)
	mock.lockSearchByAccessToken.Unlock()
	return mock.SearchByAccessTokenFunc(ctx, db, accessToken)
}

// SearchByAccessTokenCalls gets all the calls that were made to SearchByAccessToken.
// Check the length with:
//
//	len(mockedCredentialGetter.SearchByAccessTokenCalls())
func (mock *CredentialGetterMock) SearchByAccessTokenCalls() []struct {
	Ctx         context.Context
	Db          store.Queryer
	AccessToken string
} {
	var calls []struct {
		Ctx         context.Context
		Db          store.Queryer
		AccessToken string
	}
	mock.lockSearchByAccessToken.RLock()
	calls = mock.calls.SearchByAccessToken
	mock.lockSearchByAccessToken.RUnlock()
	return calls
}

// SearchByClientID calls SearchByClientIDFunc.
func (mock *CredentialGetterMock) SearchByClientID(ctx context.Context, db store.Queryer, clientID string) (bool, error) {
	if mock.SearchByClientIDFunc == nil {
		panic("CredentialGetterMock.SearchByClientIDFunc: method is nil but CredentialGetter.SearchByClientID was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       store.Queryer
		ClientID string
	}{
		Ctx:      ctx,
		Db:       db,
		ClientID: clientID,
	}
	mock.lockSearchByClientID.Lock()
	mock.calls.SearchByClientID = append(mock.calls.SearchByClientID, callInfo)
	mock.lockSearchByClientID.Unlock()
	return mock.SearchByClientIDFunc(ctx, db, clientID)
}

// SearchByClientIDCalls gets all the calls that were made to SearchByClientID.
// Check the length with:
//
//	len(mockedCredentialGetter.SearchByClientIDCalls())
func (mock *CredentialGetterMock) SearchByClientIDCalls() []struct {
	Ctx      context.Context
	Db       store.Queryer
	ClientID string
} {
	var calls []struct {
		Ctx      context.Context
		Db       store.Queryer
		ClientID string
	}
	mock.lockSearchByClientID.RLock()
	calls = mock.calls.SearchByClientID
	mock.lockSearchByClientID.RUnlock()
	return calls
}

// SearchByClientSecret calls SearchByClientSecretFunc.
func (mock *CredentialGetterMock) SearchByClientSecret(ctx context.Context, db store.Queryer, clientSecret string) (bool, error) {
	if mock.SearchByClientSecretFunc == nil {
		panic("CredentialGetterMock.SearchByClientSecretFunc: method is nil but CredentialGetter.SearchByClientSecret was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Db           store.Queryer
		ClientSecret string
	}{
		Ctx:          ctx,
		Db:           db,
		ClientSecret: clientSecret,
	}
	mock.lockSearchByClientSecret.Lock()
	mock.calls.SearchByClientSecret = append(mock.calls.SearchByClientSecret, callInfo)
	mock.lockSearchByClientSecret.Unlock()
	return mock.SearchByClientSecretFunc(ctx, db, clientSecret)
}

// SearchByClientSecretCalls gets all the calls that were made to SearchByClientSecret.
// Check the length with:
//
//	len(mockedCredentialGetter.SearchByClientSecretCalls())
func (mock *CredentialGetterMock) SearchByClientSecretCalls() []struct {
	Ctx          context.Context
	Db           store.Queryer
	ClientSecret string
} {
	var calls []struct {
		Ctx          context.Context
		Db           store.Queryer
		ClientSecret string
	}
	mock.lockSearchByClientSecret.RLock()
	calls = mock.calls.SearchByClientSecret
	mock.lockSearchByClientSecret.RUnlock()
	return calls
}

// SearchByRefreshToken calls SearchByRefreshTokenFunc.
func (mock *CredentialGetterMock) SearchByRefreshToken(ctx context.Context, db store.Queryer, refreshToken string) (bool, error) {
	if mock.SearchByRefreshTokenFunc == nil {
		panic("CredentialGetterMock.SearchByRefreshTokenFunc: method is nil but CredentialGetter.SearchByRefreshToken was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Db           store.Queryer
		RefreshToken string
	}{
		Ctx:          ctx,
		Db:           db,
		RefreshToken: refreshToken,
	}
	mock.lockSearchByRefreshToken.Lock()
	mock.calls.SearchByRefreshToken = append(mock.calls.SearchByRefreshToken, callInfo)
	mock.lockSearchByRefreshToken.Unlock()
	return mock.SearchByRefreshTokenFunc(ctx, db, refreshToken)
}

// SearchByRefreshTokenCalls gets all the calls that were made to SearchByRefreshToken.
// Check the length with:
//
//	len(mockedCredentialGetter.SearchByRefreshTokenCalls())
func (mock *CredentialGetterMock) SearchByRefreshTokenCalls() []struct {
	Ctx          context.Context
	Db           store.Queryer
	RefreshToken string
} {
	var calls []struct {
		Ctx          context.Context
		Db           store.Queryer
		RefreshToken string
	}
	mock.lockSearchByRefreshToken.RLock()
	calls = mock.calls.SearchByRefreshToken
	mock.lockSearchByRefreshToken.RUnlock()
	return calls
}

// Ensure, that CredentialSetterMock does implement CredentialSetter.
// If this is not the case, regenerate this file with moq.
var _ CredentialSetter = &CredentialSetterMock{}

// CredentialSetterMock is a mock implementation of CredentialSetter.
//
//	func TestSomethingThatUsesCredentialSetter(t *testing.T) {
//
//		// make and configure a mocked CredentialSetter
//		mockedCredentialSetter := &CredentialSetterMock{
//			SaveClientIDSecretFunc: func(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error {
//				panic("mock out the SaveClientIDSecret method")
//			},
//			SaveTokenFunc: func(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error {
//				panic("mock out the SaveToken method")
//			},
//		}
//
//		// use mockedCredentialSetter in code that requires CredentialSetter
//		// and then make assertions.
//
//	}
type CredentialSetterMock struct {
	// SaveClientIDSecretFunc mocks the SaveClientIDSecret method.
	SaveClientIDSecretFunc func(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error

	// SaveTokenFunc mocks the SaveToken method.
	SaveTokenFunc func(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error

	// calls tracks calls to the methods.
	calls struct {
		// SaveClientIDSecret holds details about calls to the SaveClientIDSecret method.
		SaveClientIDSecret []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// Param is the param argument value.
			Param *entity.MessageAPICredential
		}
		// SaveToken holds details about calls to the SaveToken method.
		SaveToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// Param is the param argument value.
			Param *entity.MessageAPICredential
		}
	}
	lockSaveClientIDSecret sync.RWMutex
	lockSaveToken          sync.RWMutex
}

// SaveClientIDSecret calls SaveClientIDSecretFunc.
func (mock *CredentialSetterMock) SaveClientIDSecret(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error {
	if mock.SaveClientIDSecretFunc == nil {
		panic("CredentialSetterMock.SaveClientIDSecretFunc: method is nil but CredentialSetter.SaveClientIDSecret was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.MessageAPICredential
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockSaveClientIDSecret.Lock()
	mock.calls.SaveClientIDSecret = append(mock.calls.SaveClientIDSecret, callInfo)
	mock.lockSaveClientIDSecret.Unlock()
	return mock.SaveClientIDSecretFunc(ctx, db, param)
}

// SaveClientIDSecretCalls gets all the calls that were made to SaveClientIDSecret.
// Check the length with:
//
//	len(mockedCredentialSetter.SaveClientIDSecretCalls())
func (mock *CredentialSetterMock) SaveClientIDSecretCalls() []struct {
	Ctx   context.Context
	Db    store.Execer
	Param *entity.MessageAPICredential
} {
	var calls []struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.MessageAPICredential
	}
	mock.lockSaveClientIDSecret.RLock()
	calls = mock.calls.SaveClientIDSecret
	mock.lockSaveClientIDSecret.RUnlock()
	return calls
}

// SaveToken calls SaveTokenFunc.
func (mock *CredentialSetterMock) SaveToken(ctx context.Context, db store.Execer, param *entity.MessageAPICredential) error {
	if mock.SaveTokenFunc == nil {
		panic("CredentialSetterMock.SaveTokenFunc: method is nil but CredentialSetter.SaveToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.MessageAPICredential
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockSaveToken.Lock()
	mock.calls.SaveToken = append(mock.calls.SaveToken, callInfo)
	mock.lockSaveToken.Unlock()
	return mock.SaveTokenFunc(ctx, db, param)
}

// SaveTokenCalls gets all the calls that were made to SaveToken.
// Check the length with:
//
//	len(mockedCredentialSetter.SaveTokenCalls())
func (mock *CredentialSetterMock) SaveTokenCalls() []struct {
	Ctx   context.Context
	Db    store.Execer
	Param *entity.MessageAPICredential
} {
	var calls []struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.MessageAPICredential
	}
	mock.lockSaveToken.RLock()
	calls = mock.calls.SaveToken
	mock.lockSaveToken.RUnlock()
	return calls
}

// Ensure, that MessageOwnerGetterMock does implement MessageOwnerGetter.
// If this is not the case, regenerate this file with moq.
var _ MessageOwnerGetter = &MessageOwnerGetterMock{}

// MessageOwnerGetterMock is a mock implementation of MessageOwnerGetter.
//
//	func TestSomethingThatUsesMessageOwnerGetter(t *testing.T) {
//
//		// make and configure a mocked MessageOwnerGetter
//		mockedMessageOwnerGetter := &MessageOwnerGetterMock{
//			GetThreadCompanyOwnerFunc: func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error) {
//				panic("mock out the GetThreadCompanyOwner method")
//			},
//			GetThreadCompanyOwnerByMessageIDFunc: func(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error) {
//				panic("mock out the GetThreadCompanyOwnerByMessageID method")
//			},
//			GetThreadStudentOwnerFunc: func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error) {
//				panic("mock out the GetThreadStudentOwner method")
//			},
//			GetThreadStudentOwnerByMessageIDFunc: func(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error) {
//				panic("mock out the GetThreadStudentOwnerByMessageID method")
//			},
//		}
//
//		// use mockedMessageOwnerGetter in code that requires MessageOwnerGetter
//		// and then make assertions.
//
//	}
type MessageOwnerGetterMock struct {
	// GetThreadCompanyOwnerFunc mocks the GetThreadCompanyOwner method.
	GetThreadCompanyOwnerFunc func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error)

	// GetThreadCompanyOwnerByMessageIDFunc mocks the GetThreadCompanyOwnerByMessageID method.
	GetThreadCompanyOwnerByMessageIDFunc func(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error)

	// GetThreadStudentOwnerFunc mocks the GetThreadStudentOwner method.
	GetThreadStudentOwnerFunc func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error)

	// GetThreadStudentOwnerByMessageIDFunc mocks the GetThreadStudentOwnerByMessageID method.
	GetThreadStudentOwnerByMessageIDFunc func(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetThreadCompanyOwner holds details about calls to the GetThreadCompanyOwner method.
		GetThreadCompanyOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageThreadID is the messageThreadID argument value.
			MessageThreadID entity.MessageThreadID
		}
		// GetThreadCompanyOwnerByMessageID holds details about calls to the GetThreadCompanyOwnerByMessageID method.
		GetThreadCompanyOwnerByMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageID is the messageID argument value.
			MessageID entity.MessageID
		}
		// GetThreadStudentOwner holds details about calls to the GetThreadStudentOwner method.
		GetThreadStudentOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageThreadID is the messageThreadID argument value.
			MessageThreadID entity.MessageThreadID
		}
		// GetThreadStudentOwnerByMessageID holds details about calls to the GetThreadStudentOwnerByMessageID method.
		GetThreadStudentOwnerByMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageID is the messageID argument value.
			MessageID entity.MessageID
		}
	}
	lockGetThreadCompanyOwner            sync.RWMutex
	lockGetThreadCompanyOwnerByMessageID sync.RWMutex
	lockGetThreadStudentOwner            sync.RWMutex
	lockGetThreadStudentOwnerByMessageID sync.RWMutex
}

// GetThreadCompanyOwner calls GetThreadCompanyOwnerFunc.
func (mock *MessageOwnerGetterMock) GetThreadCompanyOwner(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error) {
	if mock.GetThreadCompanyOwnerFunc == nil {
		panic("MessageOwnerGetterMock.GetThreadCompanyOwnerFunc: method is nil but MessageOwnerGetter.GetThreadCompanyOwner was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}{
		Ctx:             ctx,
		Db:              db,
		MessageThreadID: messageThreadID,
	}
	mock.lockGetThreadCompanyOwner.Lock()
	mock.calls.GetThreadCompanyOwner = append(mock.calls.GetThreadCompanyOwner, callInfo)
	mock.lockGetThreadCompanyOwner.Unlock()
	return mock.GetThreadCompanyOwnerFunc(ctx, db, messageThreadID)
}

// GetThreadCompanyOwnerCalls gets all the calls that were made to GetThreadCompanyOwner.
// Check the length with:
//
//	len(mockedMessageOwnerGetter.GetThreadCompanyOwnerCalls())
func (mock *MessageOwnerGetterMock) GetThreadCompanyOwnerCalls() []struct {
	Ctx             context.Context
	Db              store.Queryer
	MessageThreadID entity.MessageThreadID
} {
	var calls []struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}
	mock.lockGetThreadCompanyOwner.RLock()
	calls = mock.calls.GetThreadCompanyOwner
	mock.lockGetThreadCompanyOwner.RUnlock()
	return calls
}

// GetThreadCompanyOwnerByMessageID calls GetThreadCompanyOwnerByMessageIDFunc.
func (mock *MessageOwnerGetterMock) GetThreadCompanyOwnerByMessageID(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error) {
	if mock.GetThreadCompanyOwnerByMessageIDFunc == nil {
		panic("MessageOwnerGetterMock.GetThreadCompanyOwnerByMessageIDFunc: method is nil but MessageOwnerGetter.GetThreadCompanyOwnerByMessageID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Db        store.Queryer
		MessageID entity.MessageID
	}{
		Ctx:       ctx,
		Db:        db,
		MessageID: messageID,
	}
	mock.lockGetThreadCompanyOwnerByMessageID.Lock()
	mock.calls.GetThreadCompanyOwnerByMessageID = append(mock.calls.GetThreadCompanyOwnerByMessageID, callInfo)
	mock.lockGetThreadCompanyOwnerByMessageID.Unlock()
	return mock.GetThreadCompanyOwnerByMessageIDFunc(ctx, db, messageID)
}

// GetThreadCompanyOwnerByMessageIDCalls gets all the calls that were made to GetThreadCompanyOwnerByMessageID.
// Check the length with:
//
//	len(mockedMessageOwnerGetter.GetThreadCompanyOwnerByMessageIDCalls())
func (mock *MessageOwnerGetterMock) GetThreadCompanyOwnerByMessageIDCalls() []struct {
	Ctx       context.Context
	Db        store.Queryer
	MessageID entity.MessageID
} {
	var calls []struct {
		Ctx       context.Context
		Db        store.Queryer
		MessageID entity.MessageID
	}
	mock.lockGetThreadCompanyOwnerByMessageID.RLock()
	calls = mock.calls.GetThreadCompanyOwnerByMessageID
	mock.lockGetThreadCompanyOwnerByMessageID.RUnlock()
	return calls
}

// GetThreadStudentOwner calls GetThreadStudentOwnerFunc.
func (mock *MessageOwnerGetterMock) GetThreadStudentOwner(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (int64, error) {
	if mock.GetThreadStudentOwnerFunc == nil {
		panic("MessageOwnerGetterMock.GetThreadStudentOwnerFunc: method is nil but MessageOwnerGetter.GetThreadStudentOwner was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}{
		Ctx:             ctx,
		Db:              db,
		MessageThreadID: messageThreadID,
	}
	mock.lockGetThreadStudentOwner.Lock()
	mock.calls.GetThreadStudentOwner = append(mock.calls.GetThreadStudentOwner, callInfo)
	mock.lockGetThreadStudentOwner.Unlock()
	return mock.GetThreadStudentOwnerFunc(ctx, db, messageThreadID)
}

// GetThreadStudentOwnerCalls gets all the calls that were made to GetThreadStudentOwner.
// Check the length with:
//
//	len(mockedMessageOwnerGetter.GetThreadStudentOwnerCalls())
func (mock *MessageOwnerGetterMock) GetThreadStudentOwnerCalls() []struct {
	Ctx             context.Context
	Db              store.Queryer
	MessageThreadID entity.MessageThreadID
} {
	var calls []struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}
	mock.lockGetThreadStudentOwner.RLock()
	calls = mock.calls.GetThreadStudentOwner
	mock.lockGetThreadStudentOwner.RUnlock()
	return calls
}

// GetThreadStudentOwnerByMessageID calls GetThreadStudentOwnerByMessageIDFunc.
func (mock *MessageOwnerGetterMock) GetThreadStudentOwnerByMessageID(ctx context.Context, db store.Queryer, messageID entity.MessageID) (int64, error) {
	if mock.GetThreadStudentOwnerByMessageIDFunc == nil {
		panic("MessageOwnerGetterMock.GetThreadStudentOwnerByMessageIDFunc: method is nil but MessageOwnerGetter.GetThreadStudentOwnerByMessageID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Db        store.Queryer
		MessageID entity.MessageID
	}{
		Ctx:       ctx,
		Db:        db,
		MessageID: messageID,
	}
	mock.lockGetThreadStudentOwnerByMessageID.Lock()
	mock.calls.GetThreadStudentOwnerByMessageID = append(mock.calls.GetThreadStudentOwnerByMessageID, callInfo)
	mock.lockGetThreadStudentOwnerByMessageID.Unlock()
	return mock.GetThreadStudentOwnerByMessageIDFunc(ctx, db, messageID)
}

// GetThreadStudentOwnerByMessageIDCalls gets all the calls that were made to GetThreadStudentOwnerByMessageID.
// Check the length with:
//
//	len(mockedMessageOwnerGetter.GetThreadStudentOwnerByMessageIDCalls())
func (mock *MessageOwnerGetterMock) GetThreadStudentOwnerByMessageIDCalls() []struct {
	Ctx       context.Context
	Db        store.Queryer
	MessageID entity.MessageID
} {
	var calls []struct {
		Ctx       context.Context
		Db        store.Queryer
		MessageID entity.MessageID
	}
	mock.lockGetThreadStudentOwnerByMessageID.RLock()
	calls = mock.calls.GetThreadStudentOwnerByMessageID
	mock.lockGetThreadStudentOwnerByMessageID.RUnlock()
	return calls
}

// Ensure, that MessageGetterMock does implement MessageGetter.
// If this is not the case, regenerate this file with moq.
var _ MessageGetter = &MessageGetterMock{}

// MessageGetterMock is a mock implementation of MessageGetter.
//
//	func TestSomethingThatUsesMessageGetter(t *testing.T) {
//
//		// make and configure a mocked MessageGetter
//		mockedMessageGetter := &MessageGetterMock{
//			GetAllMessagesForCompanyUserFunc: func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error) {
//				panic("mock out the GetAllMessagesForCompanyUser method")
//			},
//			GetAllMessagesForStudentUserFunc: func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error) {
//				panic("mock out the GetAllMessagesForStudentUser method")
//			},
//		}
//
//		// use mockedMessageGetter in code that requires MessageGetter
//		// and then make assertions.
//
//	}
type MessageGetterMock struct {
	// GetAllMessagesForCompanyUserFunc mocks the GetAllMessagesForCompanyUser method.
	GetAllMessagesForCompanyUserFunc func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error)

	// GetAllMessagesForStudentUserFunc mocks the GetAllMessagesForStudentUser method.
	GetAllMessagesForStudentUserFunc func(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetAllMessagesForCompanyUser holds details about calls to the GetAllMessagesForCompanyUser method.
		GetAllMessagesForCompanyUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageThreadID is the messageThreadID argument value.
			MessageThreadID entity.MessageThreadID
		}
		// GetAllMessagesForStudentUser holds details about calls to the GetAllMessagesForStudentUser method.
		GetAllMessagesForStudentUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// MessageThreadID is the messageThreadID argument value.
			MessageThreadID entity.MessageThreadID
		}
	}
	lockGetAllMessagesForCompanyUser sync.RWMutex
	lockGetAllMessagesForStudentUser sync.RWMutex
}

// GetAllMessagesForCompanyUser calls GetAllMessagesForCompanyUserFunc.
func (mock *MessageGetterMock) GetAllMessagesForCompanyUser(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error) {
	if mock.GetAllMessagesForCompanyUserFunc == nil {
		panic("MessageGetterMock.GetAllMessagesForCompanyUserFunc: method is nil but MessageGetter.GetAllMessagesForCompanyUser was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}{
		Ctx:             ctx,
		Db:              db,
		MessageThreadID: messageThreadID,
	}
	mock.lockGetAllMessagesForCompanyUser.Lock()
	mock.calls.GetAllMessagesForCompanyUser = append(mock.calls.GetAllMessagesForCompanyUser, callInfo)
	mock.lockGetAllMessagesForCompanyUser.Unlock()
	return mock.GetAllMessagesForCompanyUserFunc(ctx, db, messageThreadID)
}

// GetAllMessagesForCompanyUserCalls gets all the calls that were made to GetAllMessagesForCompanyUser.
// Check the length with:
//
//	len(mockedMessageGetter.GetAllMessagesForCompanyUserCalls())
func (mock *MessageGetterMock) GetAllMessagesForCompanyUserCalls() []struct {
	Ctx             context.Context
	Db              store.Queryer
	MessageThreadID entity.MessageThreadID
} {
	var calls []struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}
	mock.lockGetAllMessagesForCompanyUser.RLock()
	calls = mock.calls.GetAllMessagesForCompanyUser
	mock.lockGetAllMessagesForCompanyUser.RUnlock()
	return calls
}

// GetAllMessagesForStudentUser calls GetAllMessagesForStudentUserFunc.
func (mock *MessageGetterMock) GetAllMessagesForStudentUser(ctx context.Context, db store.Queryer, messageThreadID entity.MessageThreadID) (entity.Messages, error) {
	if mock.GetAllMessagesForStudentUserFunc == nil {
		panic("MessageGetterMock.GetAllMessagesForStudentUserFunc: method is nil but MessageGetter.GetAllMessagesForStudentUser was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}{
		Ctx:             ctx,
		Db:              db,
		MessageThreadID: messageThreadID,
	}
	mock.lockGetAllMessagesForStudentUser.Lock()
	mock.calls.GetAllMessagesForStudentUser = append(mock.calls.GetAllMessagesForStudentUser, callInfo)
	mock.lockGetAllMessagesForStudentUser.Unlock()
	return mock.GetAllMessagesForStudentUserFunc(ctx, db, messageThreadID)
}

// GetAllMessagesForStudentUserCalls gets all the calls that were made to GetAllMessagesForStudentUser.
// Check the length with:
//
//	len(mockedMessageGetter.GetAllMessagesForStudentUserCalls())
func (mock *MessageGetterMock) GetAllMessagesForStudentUserCalls() []struct {
	Ctx             context.Context
	Db              store.Queryer
	MessageThreadID entity.MessageThreadID
} {
	var calls []struct {
		Ctx             context.Context
		Db              store.Queryer
		MessageThreadID entity.MessageThreadID
	}
	mock.lockGetAllMessagesForStudentUser.RLock()
	calls = mock.calls.GetAllMessagesForStudentUser
	mock.lockGetAllMessagesForStudentUser.RUnlock()
	return calls
}

// Ensure, that MessageAdderMock does implement MessageAdder.
// If this is not the case, regenerate this file with moq.
var _ MessageAdder = &MessageAdderMock{}

// MessageAdderMock is a mock implementation of MessageAdder.
//
//	func TestSomethingThatUsesMessageAdder(t *testing.T) {
//
//		// make and configure a mocked MessageAdder
//		mockedMessageAdder := &MessageAdderMock{
//			AddMessageFunc: func(ctx context.Context, db store.Execer, param *entity.Message) error {
//				panic("mock out the AddMessage method")
//			},
//		}
//
//		// use mockedMessageAdder in code that requires MessageAdder
//		// and then make assertions.
//
//	}
type MessageAdderMock struct {
	// AddMessageFunc mocks the AddMessage method.
	AddMessageFunc func(ctx context.Context, db store.Execer, param *entity.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// AddMessage holds details about calls to the AddMessage method.
		AddMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// Param is the param argument value.
			Param *entity.Message
		}
	}
	lockAddMessage sync.RWMutex
}

// AddMessage calls AddMessageFunc.
func (mock *MessageAdderMock) AddMessage(ctx context.Context, db store.Execer, param *entity.Message) error {
	if mock.AddMessageFunc == nil {
		panic("MessageAdderMock.AddMessageFunc: method is nil but MessageAdder.AddMessage was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.Message
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockAddMessage.Lock()
	mock.calls.AddMessage = append(mock.calls.AddMessage, callInfo)
	mock.lockAddMessage.Unlock()
	return mock.AddMessageFunc(ctx, db, param)
}

// AddMessageCalls gets all the calls that were made to AddMessage.
// Check the length with:
//
//	len(mockedMessageAdder.AddMessageCalls())
func (mock *MessageAdderMock) AddMessageCalls() []struct {
	Ctx   context.Context
	Db    store.Execer
	Param *entity.Message
} {
	var calls []struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.Message
	}
	mock.lockAddMessage.RLock()
	calls = mock.calls.AddMessage
	mock.lockAddMessage.RUnlock()
	return calls
}

// Ensure, that MessageEditorMock does implement MessageEditor.
// If this is not the case, regenerate this file with moq.
var _ MessageEditor = &MessageEditorMock{}

// MessageEditorMock is a mock implementation of MessageEditor.
//
//	func TestSomethingThatUsesMessageEditor(t *testing.T) {
//
//		// make and configure a mocked MessageEditor
//		mockedMessageEditor := &MessageEditorMock{
//			EditMessageFunc: func(ctx context.Context, db store.Execer, param *entity.Message) error {
//				panic("mock out the EditMessage method")
//			},
//		}
//
//		// use mockedMessageEditor in code that requires MessageEditor
//		// and then make assertions.
//
//	}
type MessageEditorMock struct {
	// EditMessageFunc mocks the EditMessage method.
	EditMessageFunc func(ctx context.Context, db store.Execer, param *entity.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// EditMessage holds details about calls to the EditMessage method.
		EditMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// Param is the param argument value.
			Param *entity.Message
		}
	}
	lockEditMessage sync.RWMutex
}

// EditMessage calls EditMessageFunc.
func (mock *MessageEditorMock) EditMessage(ctx context.Context, db store.Execer, param *entity.Message) error {
	if mock.EditMessageFunc == nil {
		panic("MessageEditorMock.EditMessageFunc: method is nil but MessageEditor.EditMessage was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.Message
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockEditMessage.Lock()
	mock.calls.EditMessage = append(mock.calls.EditMessage, callInfo)
	mock.lockEditMessage.Unlock()
	return mock.EditMessageFunc(ctx, db, param)
}

// EditMessageCalls gets all the calls that were made to EditMessage.
// Check the length with:
//
//	len(mockedMessageEditor.EditMessageCalls())
func (mock *MessageEditorMock) EditMessageCalls() []struct {
	Ctx   context.Context
	Db    store.Execer
	Param *entity.Message
} {
	var calls []struct {
		Ctx   context.Context
		Db    store.Execer
		Param *entity.Message
	}
	mock.lockEditMessage.RLock()
	calls = mock.calls.EditMessage
	mock.lockEditMessage.RUnlock()
	return calls
}

// Ensure, that MessageDeleterMock does implement MessageDeleter.
// If this is not the case, regenerate this file with moq.
var _ MessageDeleter = &MessageDeleterMock{}

// MessageDeleterMock is a mock implementation of MessageDeleter.
//
//	func TestSomethingThatUsesMessageDeleter(t *testing.T) {
//
//		// make and configure a mocked MessageDeleter
//		mockedMessageDeleter := &MessageDeleterMock{
//			DeleteMessageFunc: func(ctx context.Context, db store.Execer, id entity.MessageID) error {
//				panic("mock out the DeleteMessage method")
//			},
//		}
//
//		// use mockedMessageDeleter in code that requires MessageDeleter
//		// and then make assertions.
//
//	}
type MessageDeleterMock struct {
	// DeleteMessageFunc mocks the DeleteMessage method.
	DeleteMessageFunc func(ctx context.Context, db store.Execer, id entity.MessageID) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteMessage holds details about calls to the DeleteMessage method.
		DeleteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// ID is the id argument value.
			ID entity.MessageID
		}
	}
	lockDeleteMessage sync.RWMutex
}

// DeleteMessage calls DeleteMessageFunc.
func (mock *MessageDeleterMock) DeleteMessage(ctx context.Context, db store.Execer, id entity.MessageID) error {
	if mock.DeleteMessageFunc == nil {
		panic("MessageDeleterMock.DeleteMessageFunc: method is nil but MessageDeleter.DeleteMessage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Execer
		ID  entity.MessageID
	}{
		Ctx: ctx,
		Db:  db,
		ID:  id,
	}
	mock.lockDeleteMessage.Lock()
	mock.calls.DeleteMessage = append(mock.calls.DeleteMessage, callInfo)
	mock.lockDeleteMessage.Unlock()
	return mock.DeleteMessageFunc(ctx, db, id)
}

// DeleteMessageCalls gets all the calls that were made to DeleteMessage.
// Check the length with:
//
//	len(mockedMessageDeleter.DeleteMessageCalls())
func (mock *MessageDeleterMock) DeleteMessageCalls() []struct {
	Ctx context.Context
	Db  store.Execer
	ID  entity.MessageID
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Execer
		ID  entity.MessageID
	}
	mock.lockDeleteMessage.RLock()
	calls = mock.calls.DeleteMessage
	mock.lockDeleteMessage.RUnlock()
	return calls
}
